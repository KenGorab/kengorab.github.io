<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Articles on Blog</title>
    <link>http://kenrg.co/article/index.xml</link>
    <description>Recent content in Articles on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 07 Apr 2017 23:29:04 -0400</lastBuildDate>
    <atom:link href="http://kenrg.co/article/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Writing Snake in Javascript with Kotlin: Part 0</title>
      <link>http://kenrg.co/article/writing-snake-in-kotlin-js-0/</link>
      <pubDate>Fri, 07 Apr 2017 23:29:04 -0400</pubDate>
      
      <guid>http://kenrg.co/article/writing-snake-in-kotlin-js-0/</guid>
      <description>

&lt;p&gt;Continuing from my &lt;a href=&#34;http://kenrg.co/article/kotlin-to-javascript/&#34;&gt;previous post about Kotlin&lt;/a&gt; and its newly-added Javascript build target,
I wanted to play around with the (also recently released) &lt;a href=&#34;https://github.com/Kotlin/kotlinx.html&#34;&gt;kotlinx.html&lt;/a&gt; library. If
you&amp;rsquo;ve used &lt;a href=&#34;https://github.com/Kotlin/anko&#34;&gt;anko&lt;/a&gt; in the past (a Kotlin library for defining views in Android, among other
utilities), &lt;code&gt;kotlinx.html&lt;/code&gt; is essentially the same idea; it provides a nice &amp;ldquo;DSL&amp;rdquo; in Kotlin for creating HTML elements.&lt;/p&gt;

&lt;p&gt;I put &amp;ldquo;DSL&amp;rdquo; in quotes, because while it may &lt;em&gt;look&lt;/em&gt; like some other language, it &lt;em&gt;is&lt;/em&gt; still just normal Kotlin code, albeit taking
advantage of language features like &lt;a href=&#34;https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver&#34;&gt;function literals with receivers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, using Kotlin and Kotlinx.html, let&amp;rsquo;s try to write the game Snake and run it in the browser. All of the code will be available on
my github, and there will be a tag for steps along the way, in case you wanted to try it for yourself.&lt;/p&gt;

&lt;p&gt;If you want to check out the final result and play the game for yourself, &lt;a href=&#34;http://kenrg.co/projects/snake-kotlin-js&#34;&gt;check it out&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;This is going to be a multi-part article, so let&amp;rsquo;s get started!&lt;/p&gt;

&lt;p&gt;üêçüêçüêç&lt;/p&gt;

&lt;h1 id=&#34;step-0-project-setup&#34;&gt;Step 0: Project Setup&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m going to start with the &lt;a href=&#34;https://github.com/kengorab/kotlin-javascript-boilerplate&#34;&gt;kotlin-js-boilerplate&lt;/a&gt; that we built up in my
previous post about Kotlin and Javascript, so you can fork that if you want to follow along.&lt;/p&gt;

&lt;p&gt;After copying the template, renaming the project in the &lt;code&gt;settings.gradle&lt;/code&gt; file, and clearing out the README (we&amp;rsquo;ll fill it in later),
I replaced the &lt;code&gt;index.html&lt;/code&gt; file with this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;üêç Snake&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.css&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body class=&amp;quot;container&amp;quot;&amp;gt;
&amp;lt;h1&amp;gt;üêç Snake&amp;lt;/h1&amp;gt;

&amp;lt;script src=&amp;quot;node_modules/kotlin/kotlin.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;build/js/module.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is nearly the same as it was in the boilerplate, just removing some unnecessary html. The same scripts get pulled in
(if you&amp;rsquo;re unsure what these javascript files are, or where they come from, you should read through &lt;a href=&#34;http://localhost:1313/article/kotlin-to-javascript/&#34;&gt;my previous post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;By serving up the root project using any method you like (I like &lt;code&gt;python -m SimpleHTTPServer&lt;/code&gt; since it&amp;rsquo;s available by default on any
OS with python installed), you&amp;rsquo;ll see a very boring page with an &lt;code&gt;h1&lt;/code&gt; tag, and nothing else.  As of now, the &lt;code&gt;Main.kt&lt;/code&gt; file still just
prints &lt;code&gt;&#39;Hello World!&#39;&lt;/code&gt; to the brower console, so you should see that too. Remember to do an &lt;code&gt;npm install&lt;/code&gt;/&lt;code&gt;yarn&lt;/code&gt; before running,
since the template project pulls in the kotlin-js standard library via npm.&lt;/p&gt;

&lt;p&gt;But we didn&amp;rsquo;t come here to write HTML, we came here to write Kotlin!&lt;/p&gt;

&lt;h2 id=&#34;using-kotlinx-html&#34;&gt;Using kotlinx.html&lt;/h2&gt;

&lt;p&gt;Head over to your &lt;code&gt;build.gradle&lt;/code&gt; file. You should see the boilerplate/template stuff, applying the &lt;code&gt;kotlin2js&lt;/code&gt; plugin, and pulling in
the kotlin-js standard lib. Change the &lt;code&gt;dependencies&lt;/code&gt; section to include the &lt;code&gt;kotlinx-html-js&lt;/code&gt; dependency:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;dependencies {
  compile &amp;quot;org.jetbrains.kotlin:kotlin-stdlib-js:$kotlin_version&amp;quot;
  compile &#39;org.jetbrains.kotlinx:kotlinx-html-js:0.6.3&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note that the version may be different by the time of your reading; you can see what the latest version is by checking the
&lt;a href=&#34;https://github.com/Kotlin/kotlinx.html/releases&#34;&gt;releases&lt;/a&gt; page on the kotlinx.html github.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In order to install this dependency, we need to tell gradle where it can be found online, since it&amp;rsquo;s not in the maven central repo.
Change your &lt;code&gt;repositories&lt;/code&gt; section to look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;repositories {
  mavenCentral()
  jcenter()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note that this is the top-level &lt;code&gt;repositories&lt;/code&gt; section, not the one nested under &lt;code&gt;buildscript&lt;/code&gt; at the top.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s head back to our &lt;code&gt;index.html&lt;/code&gt; file, and remove the line with the &lt;code&gt;h1&lt;/code&gt; tag. Refreshing our browser tab that loaded that file
should result in a blank page (duh).&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s change our &lt;code&gt;Main.kt&lt;/code&gt; file to render this line, using the &lt;code&gt;kotlinx.html&lt;/code&gt; library. Here&amp;rsquo;s what it should look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;package co.kenrg.snake

import kotlinx.html.dom.append
import kotlinx.html.js.h1
import kotlin.browser.document

fun main(args: Array&amp;lt;String&amp;gt;) {
    document.body?.append {
        h1 { +&amp;quot;üêç Snake&amp;quot; }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;If you&amp;rsquo;re confused what exactly this is doing here (and what that plus sign is doing before the String) you&amp;rsquo;re not alone. I was
mystified by this library at first too. I explain what&amp;rsquo;s going on here &lt;a href=&#34;#how-does-kotlinx-html-work&#34;&gt;further&lt;/a&gt; down the page,
after we get it working.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Run &lt;code&gt;./gradlew build&lt;/code&gt;, and it should complete successfully, resulting in the generation of the &lt;code&gt;module.js&lt;/code&gt; file within the
&lt;code&gt;build/js&lt;/code&gt; directory (there are other files generated in there too, see my previous post for more info on that).&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;index.html&lt;/code&gt; file is already set up to load the &lt;code&gt;build/js/module.js&lt;/code&gt; Javascript file, as well as the kotlin-js standard library
from &lt;code&gt;node_modules&lt;/code&gt; (if you haven&amp;rsquo;t run a &lt;code&gt;npm install&lt;/code&gt;/&lt;code&gt;yarn&lt;/code&gt; yet, do it now), so let&amp;rsquo;s refresh the page.&lt;/p&gt;

&lt;p&gt;There should be an error that appears in the browser console, saying something resembling:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.js:11 Uncaught Error: Error loading module &#39;module&#39;. Its dependency &#39;kotlinx-html-js&#39; was not found. Please, check whether &#39;kotlinx-html-js&#39; is loaded prior to &#39;module&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is because our module depends not only on the kotlin-js standard library, but on the kotlinx-html-js library as well. In my last
post when I built up the boilerplate project, &lt;a href=&#34;http://kenrg.co/article/kotlin-to-javascript/#the-build-gradle-file&#34;&gt;I mentioned&lt;/a&gt;
how the kotlin-js standard library could either be extracted from the kotlin-stdlib-js dependency jar using a &lt;code&gt;build.doLast&lt;/code&gt; gradle
task, or by adding a &lt;code&gt;package.json&lt;/code&gt; and installing it as a node dependency, since the standard lib was installable as an npm package.
This is unfortunately not the case (at least not yet) for the kotlinx-html-js library. So we&amp;rsquo;ll need to add that &lt;code&gt;build.doLast&lt;/code&gt; step
after all.&lt;/p&gt;

&lt;h2 id=&#34;loading-the-kotlinx-html-js-library&#34;&gt;Loading the kotlinx-html-js library&lt;/h2&gt;

&lt;p&gt;In the Kotlin-to-Javascript setup instructions, JetBrains mentions a &lt;code&gt;build.doLast&lt;/code&gt; step that you can add to your &lt;code&gt;build.gradle&lt;/code&gt; file
in order to extract the standard lib from a jar. Since we&amp;rsquo;ll need to do that for the kotlinx-html-js library anyway (and this task
extracts all &lt;code&gt;.js&lt;/code&gt; files from jars on the classpath) we&amp;rsquo;ll no longer need to reference the kotlin-js standard library from the
&lt;code&gt;node_modules&lt;/code&gt; directory. So we can go ahead and delete &lt;code&gt;node_modules&lt;/code&gt; and the &lt;code&gt;package.json&lt;/code&gt;, and add this to your &lt;code&gt;build.gradle&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;build.doLast {
  configurations.compile.each { File file -&amp;gt;
    copy {
      includeEmptyDirs = false

      from zipTree(file.absolutePath)
      into &amp;quot;${projectDir}/build/js&amp;quot;
      include { fileTreeElement -&amp;gt;
        def path = fileTreeElement.path
        path.endsWith(&amp;quot;.js&amp;quot;) &amp;amp;&amp;amp; (path.startsWith(&amp;quot;META-INF/resources/&amp;quot;) || !path.startsWith(&amp;quot;META-INF/&amp;quot;))
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s run a &lt;code&gt;./gradlew build&lt;/code&gt; and see now that there are additional files generated in the &lt;code&gt;build/js&lt;/code&gt; directory, including: &lt;code&gt;kotlin.js&lt;/code&gt; and &lt;code&gt;kotlinx-html-js.js&lt;/code&gt;. Update the &lt;code&gt;index.html&lt;/code&gt; file to include the following script tags instead of what was previously there:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;build/js/kotlin.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;build/js/kotlinx-html-js.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;build/js/module.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Refresh the page and you should see our &lt;code&gt;h1&lt;/code&gt; tag appear! Awesome, we&amp;rsquo;ve generated some DOM elements using Kotlin, compiled to
Javascript! We&amp;rsquo;ve paved the way for the remainder of the project.&lt;/p&gt;

&lt;h2 id=&#34;how-does-kotlinx-html-work&#34;&gt;How does kotlinx-html work?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Note: This code will not be included in the github repo for this project&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is what our main function looks like in &lt;code&gt;Main.kt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;package co.kenrg.snake

import kotlinx.html.dom.append
import kotlinx.html.js.h1
import kotlin.browser.document

fun main(args: Array&amp;lt;String&amp;gt;) {
    document.body?.append {
        h1 { +&amp;quot;üêç Snake&amp;quot; }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing we do is get a handle on &lt;code&gt;document.body&lt;/code&gt;. This corresponds to the HTML node created by the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag. In our
&lt;code&gt;index.html&lt;/code&gt; file, this is empty and has a class of &lt;code&gt;&#39;container&#39;&lt;/code&gt;. The &lt;code&gt;.append&lt;/code&gt; function is an &lt;a href=&#34;https://kotlinlang.org/docs/reference/extensions.html#extension-functions&#34;&gt;extension function&lt;/a&gt;
on the &lt;code&gt;Node&lt;/code&gt; class, of which &lt;code&gt;document.body&lt;/code&gt; is an instance. Actually, it is a nullable instance, which is why we need the
null-safe operator (&lt;code&gt;?.&lt;/code&gt;) when calling &lt;code&gt;apply&lt;/code&gt;. The &lt;code&gt;apply&lt;/code&gt; function has the following signature:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun Node.append(block : TagConsumer&amp;lt;HTMLElement&amp;gt;.() -&amp;gt; Unit) : List&amp;lt;HTMLElement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;block&lt;/code&gt; parameter is a function/closure with a &lt;a href=&#34;https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver&#34;&gt;receiver&lt;/a&gt;
of &lt;code&gt;TagConsumer&amp;lt;HTMLElement&amp;gt;&lt;/code&gt;, which means that any code in that block will be executed as if it were an extension function on
&lt;code&gt;TagConsumer&amp;lt;HTMLElement&amp;gt;&lt;/code&gt;. This is how the kotlinx-html library achieves its DSL-like syntax.&lt;/p&gt;

&lt;p&gt;Within the function/closure/block (I&amp;rsquo;ve seen it called all three) we call the &lt;code&gt;h1&lt;/code&gt; function, which has the following signature:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun TagConsumer&amp;lt;HTMLElement&amp;gt;.h1(classes : String? = null, block : H1.() -&amp;gt; Unit = {}) : HTMLHeadingElement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As expected, since it&amp;rsquo;s executed within the block passed to &lt;code&gt;body.apply&lt;/code&gt;, the &lt;code&gt;h1&lt;/code&gt; function is a function on &lt;code&gt;TagConsumer&amp;lt;HtmlElement&amp;gt;&lt;/code&gt;
(an extension function to be precise, which is how all of these functions seem to be implemented). We could have
equivalently written our &lt;code&gt;main&lt;/code&gt; function as follows, with the same exact result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun main(args: Array&amp;lt;String&amp;gt;) {
    document.body?.append {
        this.h1 { +&amp;quot;üêç Snake&amp;quot; }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where the &lt;code&gt;this&lt;/code&gt; keyword in &lt;code&gt;this.h1&lt;/code&gt; refers to the &lt;code&gt;TagConsumer&amp;lt;HTMLElement&amp;gt;&lt;/code&gt; instance that the block passed to &lt;code&gt;.apply&lt;/code&gt; will be
executing within. This is definitely on the more confusing side, but I encourage you to read through the Kotlin documentation for
&lt;a href=&#34;https://kotlinlang.org/docs/reference/extensions.html#extension-functions&#34;&gt;extension functions&lt;/a&gt; and &lt;a href=&#34;https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver&#34;&gt;function literals with receiver&lt;/a&gt;
and it should help. Also, playing around with the &lt;a href=&#34;https://try.kotlinlang.org/#/Examples/Longer%20examples/HTML%20Builder/HTML%20Builder.kt&#34;&gt;HTML Builder example&lt;/a&gt;
on the Kotlin playground page will help a lot too (it definitely helped me).&lt;/p&gt;

&lt;p&gt;The only other weird thing is the &lt;code&gt;+&amp;quot;üêç Snake&amp;quot;&lt;/code&gt; line within the &lt;code&gt;h1&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;The HTML Builder example linked above differs slightly from the implementation of the kotlinx.html library, but it can definitely
provide us some insight into what&amp;rsquo;s happening here. In that example, we see this definition in the &lt;code&gt;TagWithText&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;operator fun String.unaryPlus() {
  children.add(TextElement(this))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kotlin provides us the ability to &lt;a href=&#34;https://kotlinlang.org/docs/reference/operator-overloading.html&#34;&gt;overload operators&lt;/a&gt;, which means
we can define custom implementations for the standard operators. In this case, the unary plus operator (the counterpart to the unary
minus operator, which allows us to define negative numbers) is being overridden to mean &amp;ldquo;set the text content of this element&amp;rdquo;. This,
in my opinion, is the most unintuitive part of the kotlinx.html library, but it&amp;rsquo;s a nice shortcut for defining the text content of
a DOM node. There is another (possibly less-idiomatic, but also possibly clearer) way of doing it, but first I need to show how the
library handles setting a node&amp;rsquo;s attributes, and how to nest child nodes.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;block&lt;/code&gt; parameter that&amp;rsquo;s passed into the &lt;code&gt;h1&lt;/code&gt; function executes within the context of an instance of the &lt;code&gt;H1&lt;/code&gt; class,
meaning that setting the &lt;code&gt;id&lt;/code&gt; or the &lt;code&gt;tabIndex&lt;/code&gt; properties of an &lt;code&gt;h1&lt;/code&gt; is done like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;h1 {
  id = &amp;quot;some-id&amp;quot;
  tabIndex = &amp;quot;0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;All of the attributes have type &lt;code&gt;String&lt;/code&gt;, which corresponds well to the DOM, since all attributes are passed as strings, but isn&amp;rsquo;t
extraordinarily type-safe, since &lt;code&gt;tabIndex&lt;/code&gt; should probably be an &lt;code&gt;Int&lt;/code&gt;. I have no inside sources or anything, but I&amp;rsquo;d expect this
to change over time as the library gets more mature.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here is some pseudo-code to illustrate what&amp;rsquo;s happening here with this block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val h1 = H1()
h1.id = &amp;quot;some-id&amp;quot;
h1.tabIndex = &amp;quot;0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nested DOM nodes can be defined in this way too, by adding code to the block passed to the parent&amp;rsquo;s function. For example, creating
a div with a span and a button inside of it would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;div {
  span { +&amp;quot;Some label&amp;quot; }
  button { 
    +&amp;quot;Click me&amp;quot;
    onClickFunction = { event -&amp;gt; println(&amp;quot;Button clicked!&amp;quot;) } 
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is some pseudo-code to illustrate what&amp;rsquo;s happening here with this block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val div = DIV()

val span = SPAN()
span.add(TextElement(&amp;quot;Some label&amp;quot;))
div.addChild(span)

val button = BUTTON()
button.add(TextElement(&amp;quot;Click me&amp;quot;))
button.onClickFunction = { event -&amp;gt; println(&amp;quot;Button clicked!&amp;quot;) }
div.addChild(button)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This isn&amp;rsquo;t at all what the underlying Kotlin code is doing (or at least, not &lt;em&gt;all&lt;/em&gt; that it&amp;rsquo;s doing), but it provides a good way to
conceptualize this &amp;ldquo;DSL&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m still using the &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;unaryPlus&lt;/code&gt; operator in that example above, but now that we understand nesting within these blocks, we could
substitute it with a call to the &lt;code&gt;text&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;div {
  span { text(&amp;quot;Some label&amp;quot;) }
  button { 
    text(&amp;quot;Click me&amp;quot;)
    onClickFunction = { event -&amp;gt; println(&amp;quot;Button clicked!&amp;quot;) } 
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think it&amp;rsquo;s clearer what the intent is when we use the &lt;code&gt;text&lt;/code&gt; function, but it is slightly more verbose, especially when considering
that setting the text content of a node is one of the most common use cases. It may seem unintuitive at first, but the unary plus
operator does quickly become a useful shortcut.&lt;/p&gt;

&lt;h2 id=&#34;to-be-continued&#34;&gt;To be continued&amp;hellip;&lt;/h2&gt;

&lt;p&gt;I don&amp;rsquo;t want these articles to be too long, and I think this is a good stopping point for now, so we&amp;rsquo;ll continue this in the next
one (Part 1). All of the code is &lt;a href=&#34;https://github.com/kengorab/kotlin-js-snake/tree/step-0&#34;&gt;available on my github&lt;/a&gt;, under the tag
&lt;code&gt;step-0&lt;/code&gt;. There will be future tags for future articles. Stay tuned for more!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Compiling Kotlin to Javascript</title>
      <link>http://kenrg.co/article/kotlin-to-javascript/</link>
      <pubDate>Tue, 28 Mar 2017 20:15:46 -0400</pubDate>
      
      <guid>http://kenrg.co/article/kotlin-to-javascript/</guid>
      <description>

&lt;p&gt;I really enjoy working with Kotlin. I&amp;rsquo;ve had my eye on it since its early days, and I&amp;rsquo;ve always viewed it as a language
which allows me to write Java the way that I actually &lt;em&gt;want&lt;/em&gt; to write it. No more unnecessary verbosity in declaring
variables or data classes, bindings are immutable by default, string interpolation, &lt;code&gt;map&lt;/code&gt;/&lt;code&gt;filter&lt;/code&gt;/&lt;code&gt;reduce&lt;/code&gt; without having
to use a &lt;code&gt;Stream&lt;/code&gt;&amp;hellip; you get the idea.&lt;/p&gt;

&lt;p&gt;However, after the &lt;a href=&#34;http://kotlinlang.org/docs/reference/whatsnew11.html&#34;&gt;1.1 announcement&lt;/a&gt; the other day (particularly the
part about a &lt;a href=&#34;http://kotlinlang.org/docs/reference/whatsnew11.html#javascript-backend&#34;&gt;javascript backend&lt;/a&gt;), it could be the
case that Kotlin could provide not only a better way of writing Java, but a better way of writing Javascript as well.&lt;/p&gt;

&lt;h2 id=&#34;compile-to-js-languages&#34;&gt;Compile-to-JS Languages&lt;/h2&gt;

&lt;p&gt;Now the concept of a language compiling to Javascript is nothing new. We&amp;rsquo;ve seen it before with &lt;a href=&#34;https://www.scala-js.org&#34;&gt;Scala.js&lt;/a&gt;,
&lt;a href=&#34;https://clojurescript.org&#34;&gt;ClojureScript&lt;/a&gt;, &lt;a href=&#34;http://elm-lang.org&#34;&gt;Elm&lt;/a&gt;, and even more adventurous projects like
&lt;a href=&#34;https://github.com/ghcjs/ghcjs&#34;&gt;GCHJS&lt;/a&gt;, which compiles Haskell to Javascript. And it makes sense too - since Javascript is
the only thing that can run on the web (aside from &lt;a href=&#34;http://webassembly.org&#34;&gt;WebAssembly&lt;/a&gt;, which is a bit too experimental yet), any
code that we write ultimately needs to become Javascript. Hell, even &lt;a href=&#34;http://www.typescriptlang.org&#34;&gt;Typescript&lt;/a&gt; and the latest
versions of Javascript need to be compiled to the versions that browsers support.&lt;/p&gt;

&lt;p&gt;So there&amp;rsquo;s really no way around it: if you&amp;rsquo;re writing a modern web application in 2017, you&amp;rsquo;re going to be using some compile-to-js
language. Is Kotlin that language?&lt;/p&gt;

&lt;p&gt;Well, let&amp;rsquo;s give it a shot and see how it goes.&lt;/p&gt;

&lt;h2 id=&#34;setting-up-a-project&#34;&gt;Setting up a Project&lt;/h2&gt;

&lt;p&gt;As of this writing, it&amp;rsquo;s still pretty new so there isn&amp;rsquo;t a wealth of resources available on the topic. By the time you read this,
the documentation may have been updated, but I based this on the &lt;a href=&#34;https://kotlinlang.org/docs/tutorials/javascript/getting-started-gradle/getting-started-with-gradle.html&#34;&gt;tutorials and guides&lt;/a&gt;
on the Kotlin website, and I think that&amp;rsquo;s probably the best place to start.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re using IntelliJ IDEA (including the Community Edition, which is free), there&amp;rsquo;s an option to create a Kotlin project with
gradle, using a Javascript-backend. (Previously, in older versions of the Kotlin plugin, this was labeled as experimental, but as of
the 1.1 release, that&amp;rsquo;s no longer the case. If you still see the experimental disclaimer, you should upgrade your plugin.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;img/intellij-new-project-window.png&#34; alt=&#34;IntelliJ IDEA New Project Window&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Follow the steps and you&amp;rsquo;ll be given a totally blank project, with just a &lt;code&gt;settings.gradle&lt;/code&gt; file and a &lt;code&gt;build.gradle&lt;/code&gt;. Let&amp;rsquo;s tackle
that file first. I&amp;rsquo;ll also note now that the finished result is
&lt;a href=&#34;https://github.com/kengorab/kotlin-javascript-boilerplate&#34;&gt;available on my github&lt;/a&gt;, so you can use it right away.&lt;/p&gt;

&lt;h3 id=&#34;the-build-gradle-file&#34;&gt;The build.gradle File&lt;/h3&gt;

&lt;p&gt;After creating the project through the IntelliJ IDEA setup screen, the &lt;code&gt;build.gradle&lt;/code&gt; file should look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;group &#39;co.kenrg&#39;
version &#39;1.0-SNAPSHOT&#39;

buildscript {
    ext.kotlin_version = &#39;1.1.1&#39;

    repositories {
        mavenCentral()
    }
    dependencies {
        classpath &amp;quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&amp;quot;
    }
}

apply plugin: &#39;kotlin2js&#39;

repositories {
    mavenCentral()
}

dependencies {
    compile &amp;quot;org.jetbrains.kotlin:kotlin-stdlib-js:$kotlin_version&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;(If you didn&amp;rsquo;t create the project through IntelliJ, creating a new gradle project and including these changes in your &lt;code&gt;build.gradle&lt;/code&gt;
file should produce the same results.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Following along in the Kotlin tutorial, the next thing they do is add an additional step in the gradle build process, and add
&lt;code&gt;build.doLast&lt;/code&gt;. You don&amp;rsquo;t need to do this. When the compiler generates the Javascript code from your Kotlin code, it also outputs
a file &lt;code&gt;kotlin.js&lt;/code&gt;, the Kotlin standard library in Javascript. Your compiled Javascript code will likely heavily depend on this,
so it&amp;rsquo;s a required dependency and must be loaded before our compiled code can work. However, by default the compiler puts it in
a different directory than the other compiled Javascript files, and this task moves it back.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t want to do this, you can reference the standard library installed via &lt;code&gt;npm&lt;/code&gt;/&lt;code&gt;yarn&lt;/code&gt; (I recommend
&lt;a href=&#34;https://yarnpkg.com&#34;&gt;yarn&lt;/a&gt;): &lt;code&gt;yarn add kotlin&lt;/code&gt;/&lt;code&gt;npm install --save kotlin&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The last thing to do here is to configure the compiler options. Here&amp;rsquo;s what I use in my template project, which differs slightly from
what&amp;rsquo;s in the Kotlin setup guide:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;compileKotlin2Js {
    kotlinOptions.outputFile = &amp;quot;${projectDir}/build/js/module.js&amp;quot;
    kotlinOptions.moduleKind = &amp;quot;umd&amp;quot;
    kotlinOptions.sourceMap = true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What do all of these mean? Well, the &lt;code&gt;outputFile&lt;/code&gt; tells the compiler where the compiled Javascript file should end up (&lt;code&gt;${projectDir}&lt;/code&gt;
is a variable provided by gradle, which represents the root of the project). As of this writing, the compiler does &lt;em&gt;not&lt;/em&gt; support
multiple-module builds, so all of the Kotlin code will be compiled together into one single Javascript module. This is typically
what you&amp;rsquo;d want to do with a tool like &lt;a href=&#34;https://webpack.github.io&#34;&gt;webpack&lt;/a&gt;, because it minimizes the number of files your users&amp;rsquo;
browsers will have to request. Typically, project code is split into the code that you write, and a &amp;ldquo;vendor&amp;rdquo; file, which is a bundle
of all of your code&amp;rsquo;s dependencies (like React, Redux, etc).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;moduleKind&lt;/code&gt; here is set to &lt;code&gt;&amp;quot;umd&amp;quot;&lt;/code&gt;; the options are &lt;code&gt;plain&lt;/code&gt;, &lt;code&gt;amd&lt;/code&gt;, &lt;code&gt;commonjs&lt;/code&gt;, and &lt;code&gt;umd&lt;/code&gt;. For those not familiar with Javascript
module loaders, here&amp;rsquo;s a brief rundown:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;plain&lt;/code&gt;: This is the old-school way to work with Javascript; put a bunch of &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your html file, and all of your code
references variables on &lt;code&gt;window&lt;/code&gt; (global scope).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;amd&lt;/code&gt;: An evolution of the plain method above, it provided a way for Javascript modules to define and provide dependencies for
other modules, and loaders like &lt;a href=&#34;http://requirejs.org&#34;&gt;require.js&lt;/a&gt; could request them asynchronously as the page loaded.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;commonjs&lt;/code&gt;: CommonJS is more well-suited for server-side Javascript, and is the module loading system used in Node.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;umd&lt;/code&gt;: &amp;ldquo;Universal Module Definition&amp;rdquo;; allows modules to intelligently decide which context they&amp;rsquo;re being loaded into (AMD,
CommonJS, or plain) and performs the necessary initialization and dependency providing. When in doubt, use UMD.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The last option is &lt;code&gt;sourceMap&lt;/code&gt;, which I&amp;rsquo;ve set to &lt;code&gt;true&lt;/code&gt;. Source maps are excellent tools for debugging; since our compiled Javascript
is generated code, it&amp;rsquo;s not the prettiest to read, which could make debugging difficult. However, sourcemaps provide a way for
debugging tools to reference the compiled code back to the original code (in our case, the Kotlin), so errors and breakpoints will
appear with respect to the Kotlin, and not the generated, messy Javascript. It&amp;rsquo;s an invaluable tool!&lt;/p&gt;

&lt;h3 id=&#34;bring-on-the-kotlin&#34;&gt;Bring on the Kotlin!&lt;/h3&gt;

&lt;p&gt;Okay, that was a lot of setup and explanation around the &lt;code&gt;build.gradle&lt;/code&gt; file, let&amp;rsquo;s get onto writing some Kotlin!&lt;/p&gt;

&lt;p&gt;Honestly, this is the part which I&amp;rsquo;ll talk about the least, since my goal here is to get everything up and running and not to explore
everything that we can do just yet. Disappointing maybe, but I&amp;rsquo;ll elaborate more in future posts.&lt;/p&gt;

&lt;p&gt;Since there&amp;rsquo;s nothing in the project except for the gradle files, let&amp;rsquo;s create a Kotlin file, using the standard project organization
directory structure: &lt;code&gt;src/main/kotlin/co/kenrg/example/Main.kt&lt;/code&gt;. You can choose whatever package name you want. Here&amp;rsquo;s what I put in
that file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;package co.kenrg.example

fun main(args: Array&amp;lt;String&amp;gt;) {
    println(&amp;quot;Hello World!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Boring, I know. &amp;ldquo;Hello World, what&amp;rsquo;s so cool about that?&amp;rdquo; you may be saying. Well, let&amp;rsquo;s give this a compile and see what we get!&lt;/p&gt;

&lt;p&gt;In your terminal, run &lt;code&gt;./gradlew build&lt;/code&gt;, and when it finishes check out the &lt;code&gt;build/js&lt;/code&gt; directory. You should see a &lt;code&gt;module/&lt;/code&gt; directory,
a &lt;code&gt;module.js&lt;/code&gt; file, a &lt;code&gt;module.js.map&lt;/code&gt; file, and a &lt;code&gt;module.meta.js&lt;/code&gt; file. For now, let&amp;rsquo;s just concern ourselves with &lt;code&gt;module.js&lt;/code&gt;, which
is our compiled Kotlin code! You can take a look at the file, but you don&amp;rsquo;t really need to ever know about what goes on in those
compiled files, thanks to sourcemaps (that&amp;rsquo;s the &lt;code&gt;module.js.map&lt;/code&gt; file, in case you were wondering).&lt;/p&gt;

&lt;h2 id=&#34;running-our-compiled-javascript&#34;&gt;Running our Compiled Javascript&lt;/h2&gt;

&lt;p&gt;Now that we&amp;rsquo;ve built our Kotlin and have compiled Javascript, let&amp;rsquo;s run it! If you followed my earlier instruction to
&lt;code&gt;yarn add kotlin&lt;/code&gt;/&lt;code&gt;npm install --save kotlin&lt;/code&gt; (you may have needed to do a &lt;code&gt;yarn init&lt;/code&gt;/&lt;code&gt;npm init&lt;/code&gt; first), then we&amp;rsquo;re ready to run
our compiled Javascript against Node!&lt;/p&gt;

&lt;p&gt;In your terminal, run &lt;code&gt;node build/js/module.js&lt;/code&gt;, and you should see the output &amp;ldquo;Hello World&amp;rdquo;. Awesome, we&amp;rsquo;ve compiled our Kotlin code
to Javascript, and are running against Node server-side. Take a moment and think about how cool that is!&lt;/p&gt;

&lt;p&gt;But what about running in the browser?&lt;/p&gt;

&lt;p&gt;Well, if you remember, we&amp;rsquo;ve told the compiler that we want to compile into the UMD format, so running in the browser shouldn&amp;rsquo;t be too
difficult. Let&amp;rsquo;s make an &lt;code&gt;index.html&lt;/code&gt; file in the root of our project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Kotlin to Javascript&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script src=&amp;quot;node_modules/kotlin/kotlin.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;build/js/module.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;The &lt;code&gt;index.html&lt;/code&gt; file in my template project is a little more decorated than this; this is barebones enough to see some output.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll notice that there are two script tags, one for the standard library (which &lt;code&gt;npm&lt;/code&gt;/&lt;code&gt;yarn&lt;/code&gt; has installed into the &lt;code&gt;node_modules&lt;/code&gt;
directory for us), and another for the Javascript assets we&amp;rsquo;ve built with &lt;code&gt;./gradlew build&lt;/code&gt;. This is the old-school. &amp;ldquo;plain&amp;rdquo; way of
handling Javascript dependencies - files with dependencies on other files should be included after those dependent files. (You can
imagine how difficult this can get to manage, which is why module loading solutions like AMD, CommonJS, and UMD were developed).&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s open up this file in your web browser of choice (you can just open it up by dragging the file into a new Chrome window, using
the &lt;code&gt;file://&lt;/code&gt; protocol linking to the file&amp;rsquo;s patch on your filesystem, or by running &lt;code&gt;python -m SimpleHTTPServer&lt;/code&gt; at the project
root and hitting &lt;code&gt;http://localhost:8000&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;If we look in the console, we see our &amp;ldquo;Hello World!&amp;rdquo; message! Awesome, so we&amp;rsquo;ve run the same Javascript code on the server-side using
Node, and in the browser. Who even cares that it&amp;rsquo;s just a simple Hello World app&amp;hellip; ship it!&lt;/p&gt;

&lt;h2 id=&#34;okay-that-s-cool-but&#34;&gt;Okay that&amp;rsquo;s cool, but&amp;hellip;&lt;/h2&gt;

&lt;p&gt;Yeah, I know, a Hello World application isn&amp;rsquo;t very awe-inspiring.&lt;/p&gt;

&lt;p&gt;But that wasn&amp;rsquo;t my intention with this. There&amp;rsquo;s no point in writing a full-fledged React application in Kotlin to compile to Javascript
if you can&amp;rsquo;t the Javascript-compilation step working correctly first. The cool stuff (not that this isn&amp;rsquo;t cool, mind you!) can come
later now that the groundwork is in place. Everything needs a foundation on which to build!&lt;/p&gt;

&lt;h2 id=&#34;what-s-next&#34;&gt;What&amp;rsquo;s Next?&lt;/h2&gt;

&lt;p&gt;Well, starting from here we&amp;rsquo;ve gotten Kotlin to compile to Javascript that can execute in either the browser or in Node&amp;hellip; where do
we go next? Well, you should definitely check out the &lt;a href=&#34;https://github.com/Kotlin/kotlinx.html&#34;&gt;kotlinx.html&lt;/a&gt; library, which provides
an idiomatic-Kotlin way of writing HTML. Also, &lt;a href=&#34;https://youtu.be/QQKdFFRqamg?t=21m8s&#34;&gt;showcased a bit&lt;/a&gt; during the Kotlin 1.1 Event
last week was a React Kotlin wrapper library. When I asked later at the Q&amp;amp;A session about its release date, Andrey replied that it&amp;rsquo;s
&amp;ldquo;coming soon&amp;rdquo;, so I&amp;rsquo;ll definitely be on the lookout for that!&lt;/p&gt;

&lt;p&gt;Aside from that, I&amp;rsquo;m going to continue to explore Kotlin&amp;rsquo;s Javascript build target, delving into how I can call existing libraries
(like lodash, perhaps) from Kotlin as well as the opposite, calling compiled-to-javascript Kotlin from existing Javascript code. I&amp;rsquo;ll
try to record my findings and maybe publish another post about that soon.&lt;/p&gt;

&lt;p&gt;I encourage you to look at the &lt;a href=&#34;https://github.com/kengorab/kotlin-javascript-boilerplate&#34;&gt;code included in this article&lt;/a&gt;, and maybe
even fork it for your own project. Let me know if you have any suggestions for it as well. I&amp;rsquo;ll probably add additional branches/tags
for other investigations I do in there, but I&amp;rsquo;ll leave &lt;code&gt;master&lt;/code&gt; in the state it&amp;rsquo;s in as of this post.&lt;/p&gt;

&lt;h2 id=&#34;should-i-use-this-for-my-next-project&#34;&gt;Should I use this for my next project?&lt;/h2&gt;

&lt;p&gt;Probably not. It&amp;rsquo;s still very new, the documentation is lacking, and there are much more mature alternatives out there at the moment.
Don&amp;rsquo;t get me wrong, it&amp;rsquo;s definitely a project I have my eyes on, but there&amp;rsquo;s no way it&amp;rsquo;s going to compete with Scala.js right out of
the gate, or Clojurescript with &lt;a href=&#34;https://reagent-project.github.io&#34;&gt;reagent&lt;/a&gt; and &lt;a href=&#34;https://github.com/Day8/re-frame&#34;&gt;re-frame&lt;/a&gt;. The
libraries, adoption, and interest just aren&amp;rsquo;t high enough yet.&lt;/p&gt;

&lt;p&gt;But definitely stay tuned to the project, I anticipate big things from the Kotlin team.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>